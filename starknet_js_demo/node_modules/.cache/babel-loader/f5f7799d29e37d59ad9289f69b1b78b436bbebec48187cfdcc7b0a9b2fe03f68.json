{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMessageHash = exports.getStructHash = exports.encodeData = exports.encodeValue = exports.getTypeHash = exports.encodeType = exports.getDependencies = exports.isMerkleTreeType = exports.prepareSelector = void 0;\nvar hash_1 = require(\"../hash\");\nvar merkle_1 = require(\"../merkle\");\nvar number_1 = require(\"../number\");\nvar shortString_1 = require(\"../shortString\");\nvar utils_1 = require(\"./utils\");\n__exportStar(require(\"./types\"), exports);\nfunction getHex(value) {\n  try {\n    return (0, number_1.toHex)((0, number_1.toBN)(value));\n  } catch (e) {\n    if (typeof value === 'string') {\n      return (0, number_1.toHex)((0, number_1.toBN)((0, shortString_1.encodeShortString)(value)));\n    }\n    throw new Error(\"Invalid BigNumberish: \".concat(value));\n  }\n}\nfunction prepareSelector(selector) {\n  return (0, number_1.isHex)(selector) ? selector : (0, hash_1.getSelectorFromName)(selector);\n}\nexports.prepareSelector = prepareSelector;\nfunction isMerkleTreeType(type) {\n  return type.type === 'merkletree';\n}\nexports.isMerkleTreeType = isMerkleTreeType;\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {string[]} [dependencies]\n * @return {string[]}\n */\nvar getDependencies = function (types, type, dependencies) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n  // Include pointers (struct arrays)\n  if (type[type.length - 1] === '*') {\n    // eslint-disable-next-line no-param-reassign\n    type = type.slice(0, -1);\n  }\n  if (dependencies.includes(type)) {\n    return dependencies;\n  }\n  if (!types[type]) {\n    return dependencies;\n  }\n  return __spreadArray([type], __read(types[type].reduce(function (previous, t) {\n    return __spreadArray(__spreadArray([], __read(previous), false), __read((0, exports.getDependencies)(types, t.type, previous).filter(function (dependency) {\n      return !previous.includes(dependency);\n    })), false);\n  }, [])), false);\n};\nexports.getDependencies = getDependencies;\nfunction getMerkleTreeType(types, ctx) {\n  if (ctx.parent && ctx.key) {\n    var parentType = types[ctx.parent];\n    var merkleType = parentType.find(function (t) {\n      return t.name === ctx.key;\n    });\n    var isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(\"\".concat(ctx.key, \" is not a merkle tree\"));\n    }\n    if (merkleType.contains.endsWith('*')) {\n      throw new Error(\"Merkle tree contain property must not be an array but was given \".concat(ctx.key));\n    }\n    return merkleType.contains;\n  }\n  return 'raw';\n}\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {string}\n */\nvar encodeType = function (types, type) {\n  var _a = __read((0, exports.getDependencies)(types, type)),\n    primary = _a[0],\n    dependencies = _a.slice(1);\n  var newTypes = !primary ? [] : __spreadArray([primary], __read(dependencies.sort()), false);\n  return newTypes.map(function (dependency) {\n    return \"\".concat(dependency, \"(\").concat(types[dependency].map(function (t) {\n      return \"\".concat(t.name, \":\").concat(t.type);\n    }), \")\");\n  }).join('');\n};\nexports.encodeType = encodeType;\n/**\n * Get a type string as hash.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {string}\n */\nvar getTypeHash = function (types, type) {\n  return (0, hash_1.getSelectorFromName)((0, exports.encodeType)(types, type));\n};\nexports.getTypeHash = getTypeHash;\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {any} data\n * @returns {[string, string]}\n */\nvar encodeValue = function (types, type, data, ctx) {\n  if (ctx === void 0) {\n    ctx = {};\n  }\n  if (types[type]) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return [type, (0, exports.getStructHash)(types, type, data)];\n  }\n  if (Object.keys(types).map(function (x) {\n    return \"\".concat(x, \"*\");\n  }).includes(type)) {\n    var structHashes = data.map(function (struct) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return (0, exports.getStructHash)(types, type.slice(0, -1), struct);\n    });\n    return [type, (0, hash_1.computeHashOnElements)(structHashes)];\n  }\n  if (type === 'merkletree') {\n    var merkleTreeType_1 = getMerkleTreeType(types, ctx);\n    var structHashes = data.map(function (struct) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return (0, exports.encodeValue)(types, merkleTreeType_1, struct)[1];\n    });\n    var root = new merkle_1.MerkleTree(structHashes).root;\n    return ['felt', root];\n  }\n  if (type === 'felt*') {\n    return ['felt*', (0, hash_1.computeHashOnElements)(data)];\n  }\n  if (type === 'selector') {\n    return ['felt', prepareSelector(data)];\n  }\n  return [type, getHex(data)];\n};\nexports.encodeValue = encodeValue;\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n */\nvar encodeData = function (types, type, data) {\n  var _a = __read(types[type].reduce(function (_a, field) {\n      var _b = __read(_a, 2),\n        ts = _b[0],\n        vs = _b[1];\n      if (data[field.name] === undefined || data[field.name] === null) {\n        throw new Error(\"Cannot encode data: missing data for '\".concat(field.name, \"'\"));\n      }\n      var value = data[field.name];\n      var _c = __read((0, exports.encodeValue)(types, field.type, value, {\n          parent: type,\n          key: field.name\n        }), 2),\n        t = _c[0],\n        encodedValue = _c[1];\n      return [__spreadArray(__spreadArray([], __read(ts), false), [t], false), __spreadArray(__spreadArray([], __read(vs), false), [encodedValue], false)];\n    }, [['felt'], [(0, exports.getTypeHash)(types, type)]]), 2),\n    returnTypes = _a[0],\n    values = _a[1];\n  return [returnTypes, values];\n};\nexports.encodeData = encodeData;\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n * @return {Buffer}\n */\nvar getStructHash = function (types, type, data) {\n  return (0, hash_1.computeHashOnElements)((0, exports.encodeData)(types, type, data)[1]);\n};\nexports.getStructHash = getStructHash;\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object.\n *\n * @param {TypedData} typedData\n * @param {BigNumberish} account\n * @return {string}\n */\nvar getMessageHash = function (typedData, account) {\n  if (!(0, utils_1.validateTypedData)(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n  var message = [(0, shortString_1.encodeShortString)('StarkNet Message'), (0, exports.getStructHash)(typedData.types, 'StarkNetDomain', typedData.domain), account, (0, exports.getStructHash)(typedData.types, typedData.primaryType, typedData.message)];\n  return (0, hash_1.computeHashOnElements)(message);\n};\nexports.getMessageHash = getMessageHash;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","p","prototype","hasOwnProperty","call","__read","n","Symbol","iterator","i","r","ar","e","next","done","push","value","error","__spreadArray","to","from","pack","arguments","length","l","Array","slice","concat","getMessageHash","getStructHash","encodeData","encodeValue","getTypeHash","encodeType","getDependencies","isMerkleTreeType","prepareSelector","hash_1","require","merkle_1","number_1","shortString_1","utils_1","getHex","toHex","toBN","encodeShortString","Error","selector","isHex","getSelectorFromName","type","types","dependencies","includes","reduce","previous","t","filter","dependency","getMerkleTreeType","ctx","parent","key","parentType","merkleType","find","name","isMerkleTree","contains","endsWith","_a","primary","newTypes","sort","map","join","data","keys","x","structHashes","struct","computeHashOnElements","merkleTreeType_1","root","MerkleTree","field","_b","ts","vs","_c","encodedValue","returnTypes","values","typedData","account","validateTypedData","message","domain","primaryType"],"sources":["C:/Users/admin/Documents/Blockchain test/CairoBootcamp/starknet_js_demo/node_modules/starknet/dist/utils/typedData/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getMessageHash = exports.getStructHash = exports.encodeData = exports.encodeValue = exports.getTypeHash = exports.encodeType = exports.getDependencies = exports.isMerkleTreeType = exports.prepareSelector = void 0;\nvar hash_1 = require(\"../hash\");\nvar merkle_1 = require(\"../merkle\");\nvar number_1 = require(\"../number\");\nvar shortString_1 = require(\"../shortString\");\nvar utils_1 = require(\"./utils\");\n__exportStar(require(\"./types\"), exports);\nfunction getHex(value) {\n    try {\n        return (0, number_1.toHex)((0, number_1.toBN)(value));\n    }\n    catch (e) {\n        if (typeof value === 'string') {\n            return (0, number_1.toHex)((0, number_1.toBN)((0, shortString_1.encodeShortString)(value)));\n        }\n        throw new Error(\"Invalid BigNumberish: \".concat(value));\n    }\n}\nfunction prepareSelector(selector) {\n    return (0, number_1.isHex)(selector) ? selector : (0, hash_1.getSelectorFromName)(selector);\n}\nexports.prepareSelector = prepareSelector;\nfunction isMerkleTreeType(type) {\n    return type.type === 'merkletree';\n}\nexports.isMerkleTreeType = isMerkleTreeType;\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {string[]} [dependencies]\n * @return {string[]}\n */\nvar getDependencies = function (types, type, dependencies) {\n    if (dependencies === void 0) { dependencies = []; }\n    // Include pointers (struct arrays)\n    if (type[type.length - 1] === '*') {\n        // eslint-disable-next-line no-param-reassign\n        type = type.slice(0, -1);\n    }\n    if (dependencies.includes(type)) {\n        return dependencies;\n    }\n    if (!types[type]) {\n        return dependencies;\n    }\n    return __spreadArray([\n        type\n    ], __read(types[type].reduce(function (previous, t) { return __spreadArray(__spreadArray([], __read(previous), false), __read((0, exports.getDependencies)(types, t.type, previous).filter(function (dependency) { return !previous.includes(dependency); })), false); }, [])), false);\n};\nexports.getDependencies = getDependencies;\nfunction getMerkleTreeType(types, ctx) {\n    if (ctx.parent && ctx.key) {\n        var parentType = types[ctx.parent];\n        var merkleType = parentType.find(function (t) { return t.name === ctx.key; });\n        var isMerkleTree = isMerkleTreeType(merkleType);\n        if (!isMerkleTree) {\n            throw new Error(\"\".concat(ctx.key, \" is not a merkle tree\"));\n        }\n        if (merkleType.contains.endsWith('*')) {\n            throw new Error(\"Merkle tree contain property must not be an array but was given \".concat(ctx.key));\n        }\n        return merkleType.contains;\n    }\n    return 'raw';\n}\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {string}\n */\nvar encodeType = function (types, type) {\n    var _a = __read((0, exports.getDependencies)(types, type)), primary = _a[0], dependencies = _a.slice(1);\n    var newTypes = !primary ? [] : __spreadArray([primary], __read(dependencies.sort()), false);\n    return newTypes\n        .map(function (dependency) {\n        return \"\".concat(dependency, \"(\").concat(types[dependency].map(function (t) { return \"\".concat(t.name, \":\").concat(t.type); }), \")\");\n    })\n        .join('');\n};\nexports.encodeType = encodeType;\n/**\n * Get a type string as hash.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {string}\n */\nvar getTypeHash = function (types, type) {\n    return (0, hash_1.getSelectorFromName)((0, exports.encodeType)(types, type));\n};\nexports.getTypeHash = getTypeHash;\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {any} data\n * @returns {[string, string]}\n */\nvar encodeValue = function (types, type, data, ctx) {\n    if (ctx === void 0) { ctx = {}; }\n    if (types[type]) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return [type, (0, exports.getStructHash)(types, type, data)];\n    }\n    if (Object.keys(types)\n        .map(function (x) { return \"\".concat(x, \"*\"); })\n        .includes(type)) {\n        var structHashes = data.map(function (struct) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return (0, exports.getStructHash)(types, type.slice(0, -1), struct);\n        });\n        return [type, (0, hash_1.computeHashOnElements)(structHashes)];\n    }\n    if (type === 'merkletree') {\n        var merkleTreeType_1 = getMerkleTreeType(types, ctx);\n        var structHashes = data.map(function (struct) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return (0, exports.encodeValue)(types, merkleTreeType_1, struct)[1];\n        });\n        var root = new merkle_1.MerkleTree(structHashes).root;\n        return ['felt', root];\n    }\n    if (type === 'felt*') {\n        return ['felt*', (0, hash_1.computeHashOnElements)(data)];\n    }\n    if (type === 'selector') {\n        return ['felt', prepareSelector(data)];\n    }\n    return [type, getHex(data)];\n};\nexports.encodeValue = encodeValue;\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n */\nvar encodeData = function (types, type, data) {\n    var _a = __read(types[type].reduce(function (_a, field) {\n        var _b = __read(_a, 2), ts = _b[0], vs = _b[1];\n        if (data[field.name] === undefined || data[field.name] === null) {\n            throw new Error(\"Cannot encode data: missing data for '\".concat(field.name, \"'\"));\n        }\n        var value = data[field.name];\n        var _c = __read((0, exports.encodeValue)(types, field.type, value, {\n            parent: type,\n            key: field.name,\n        }), 2), t = _c[0], encodedValue = _c[1];\n        return [\n            __spreadArray(__spreadArray([], __read(ts), false), [t], false),\n            __spreadArray(__spreadArray([], __read(vs), false), [encodedValue], false),\n        ];\n    }, [['felt'], [(0, exports.getTypeHash)(types, type)]]), 2), returnTypes = _a[0], values = _a[1];\n    return [returnTypes, values];\n};\nexports.encodeData = encodeData;\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n * @return {Buffer}\n */\nvar getStructHash = function (types, type, data) {\n    return (0, hash_1.computeHashOnElements)((0, exports.encodeData)(types, type, data)[1]);\n};\nexports.getStructHash = getStructHash;\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object.\n *\n * @param {TypedData} typedData\n * @param {BigNumberish} account\n * @return {string}\n */\nvar getMessageHash = function (typedData, account) {\n    if (!(0, utils_1.validateTypedData)(typedData)) {\n        throw new Error('Typed data does not match JSON schema');\n    }\n    var message = [\n        (0, shortString_1.encodeShortString)('StarkNet Message'),\n        (0, exports.getStructHash)(typedData.types, 'StarkNetDomain', typedData.domain),\n        account,\n        (0, exports.getStructHash)(typedData.types, typedData.primaryType, typedData.message),\n    ];\n    return (0, hash_1.computeHashOnElements)(message);\n};\nexports.getMessageHash = getMessageHash;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}