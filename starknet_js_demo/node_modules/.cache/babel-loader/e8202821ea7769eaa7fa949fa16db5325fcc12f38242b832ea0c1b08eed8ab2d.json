{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Contract = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar minimalistic_assert_1 = __importDefault(require(\"minimalistic-assert\"));\nvar provider_1 = require(\"../provider\");\nvar number_1 = require(\"../utils/number\");\nfunction parseFelt(candidate) {\n  try {\n    return (0, number_1.toBN)(candidate);\n  } catch (e) {\n    throw Error('Couldnt parse felt');\n  }\n}\n/**\n * Adds call methods to the contract\n *\n */\nfunction buildCall(contract, functionAbi) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, contract.call(functionAbi.name, args)];\n      });\n    });\n  };\n}\n/**\n * Adds invoke methods to the contract\n *\n */\nfunction buildInvoke(contract, functionAbi) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var inputs, inputsLength, options;\n      return __generator(this, function (_a) {\n        inputs = functionAbi.inputs;\n        inputsLength = inputs.reduce(function (acc, input) {\n          if (!/_len$/.test(input.name)) {\n            return acc + 1;\n          }\n          return acc;\n        }, 0);\n        options = {};\n        if (inputsLength + 1 === args.length && typeof args[args.length - 1] === 'object') {\n          Object.assign(options, args.pop());\n        }\n        return [2 /*return*/, contract.invoke(functionAbi.name, args, options)];\n      });\n    });\n  };\n}\n/**\n * Adds call/invoke methods to the contract\n *\n */\nfunction buildDefault(contract, functionAbi) {\n  if (functionAbi.stateMutability === 'view') {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\n/**\n * Adds populate for methods to the contract\n *\n */\nfunction buildPopulate(contract, functionAbi) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return contract.populate(functionAbi.name, args);\n  };\n}\n/**\n * Adds estimateFee for methods to the contract\n *\n */\nfunction buildEstimate(contract, functionAbi) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return contract.estimate(functionAbi.name, args);\n  };\n}\nvar Contract = /** @class */function () {\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  function Contract(abi, address, providerOrAccount) {\n    if (providerOrAccount === void 0) {\n      providerOrAccount = provider_1.defaultProvider;\n    }\n    var _this = this;\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.abi = abi;\n    this.structs = abi.filter(function (abiEntry) {\n      return abiEntry.type === 'struct';\n    }).reduce(function (acc, abiEntry) {\n      var _a;\n      return __assign(__assign({}, acc), (_a = {}, _a[abiEntry.name] = abiEntry, _a));\n    }, {});\n    Object.defineProperty(this, 'functions', {\n      enumerable: true,\n      value: {},\n      writable: false\n    });\n    Object.defineProperty(this, 'callStatic', {\n      enumerable: true,\n      value: {},\n      writable: false\n    });\n    Object.defineProperty(this, 'populateTransaction', {\n      enumerable: true,\n      value: {},\n      writable: false\n    });\n    Object.defineProperty(this, 'estimateFee', {\n      enumerable: true,\n      value: {},\n      writable: false\n    });\n    this.abi.forEach(function (abiElement) {\n      if (abiElement.type !== 'function') {\n        return;\n      }\n      var signature = abiElement.name;\n      if (!_this[signature]) {\n        Object.defineProperty(_this, signature, {\n          enumerable: true,\n          value: buildDefault(_this, abiElement),\n          writable: false\n        });\n      }\n      if (!_this.functions[signature]) {\n        Object.defineProperty(_this.functions, signature, {\n          enumerable: true,\n          value: buildDefault(_this, abiElement),\n          writable: false\n        });\n      }\n      if (!_this.callStatic[signature]) {\n        Object.defineProperty(_this.callStatic, signature, {\n          enumerable: true,\n          value: buildCall(_this, abiElement),\n          writable: false\n        });\n      }\n      if (!_this.populateTransaction[signature]) {\n        Object.defineProperty(_this.populateTransaction, signature, {\n          enumerable: true,\n          value: buildPopulate(_this, abiElement),\n          writable: false\n        });\n      }\n      if (!_this.estimateFee[signature]) {\n        Object.defineProperty(_this.estimateFee, signature, {\n          enumerable: true,\n          value: buildEstimate(_this, abiElement),\n          writable: false\n        });\n      }\n    });\n  }\n  /**\n   * Saves the address of the contract deployed on network that will be used for interaction\n   *\n   * @param address - address of the contract\n   */\n  Contract.prototype.attach = function (address) {\n    this.address = address;\n  };\n  /**\n   * Attaches to new Provider or Account\n   *\n   * @param providerOrAccount - new Provider or Account to attach to\n   */\n  Contract.prototype.connect = function (providerOrAccount) {\n    this.providerOrAccount = providerOrAccount;\n  };\n  /**\n   * Resolves when contract is deployed on the network or when no deployment transaction is found\n   *\n   * @returns Promise that resolves when contract is deployed on the network or when no deployment transaction is found\n   * @throws When deployment fails\n   */\n  Contract.prototype.deployed = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.deployTransactionHash) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.providerOrAccount.waitForTransaction(this.deployTransactionHash)];\n          case 1:\n            _a.sent();\n            this.deployTransactionHash = undefined;\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/, this];\n        }\n      });\n    });\n  };\n  /**\n   * Validates if all arguments that are passed to the method are corresponding to the ones in the abi\n   *\n   * @param type - type of the method\n   * @param method  - name of the method\n   * @param args - arguments that are passed to the method\n   */\n  Contract.prototype.validateMethodAndArgs = function (type, method, args) {\n    var _this = this;\n    if (args === void 0) {\n      args = [];\n    }\n    // ensure provided method exists\n    var invokeableFunctionNames = this.abi.filter(function (abi) {\n      if (abi.type !== 'function') return false;\n      var isView = abi.stateMutability === 'view';\n      return type === 'INVOKE' ? !isView : isView;\n    }).map(function (abi) {\n      return abi.name;\n    });\n    (0, minimalistic_assert_1.default)(invokeableFunctionNames.includes(method), \"\".concat(type === 'INVOKE' ? 'invokeable' : 'viewable', \" method not found in abi\"));\n    // ensure args match abi type\n    var methodAbi = this.abi.find(function (abi) {\n      return abi.name === method && abi.type === 'function';\n    });\n    var argPosition = 0;\n    methodAbi.inputs.forEach(function (input) {\n      if (/_len$/.test(input.name)) {\n        return;\n      }\n      if (input.type === 'felt') {\n        (0, minimalistic_assert_1.default)(typeof args[argPosition] === 'string' || typeof args[argPosition] === 'number' || args[argPosition] instanceof bn_js_1.default, \"arg \".concat(input.name, \" should be a felt (string, number, BigNumber)\"));\n        argPosition += 1;\n      } else if (input.type in _this.structs && typeof args[argPosition] === 'object') {\n        if (Array.isArray(args[argPosition])) {\n          var structMembersLength = _this.calculateStructMembers(input.type);\n          (0, minimalistic_assert_1.default)(args[argPosition].length === structMembersLength, \"arg should be of length \".concat(structMembersLength));\n        } else {\n          _this.structs[input.type].members.forEach(function (_a) {\n            var name = _a.name;\n            (0, minimalistic_assert_1.default)(Object.keys(args[argPosition]).includes(name), \"arg should have a property \".concat(name));\n          });\n        }\n        argPosition += 1;\n      } else {\n        (0, minimalistic_assert_1.default)(Array.isArray(args[argPosition]), \"arg \".concat(input.name, \" should be an Array\"));\n        if (input.type === 'felt*') {\n          args[argPosition].forEach(function (felt) {\n            (0, minimalistic_assert_1.default)(typeof felt === 'string' || typeof felt === 'number' || felt instanceof bn_js_1.default, \"arg \".concat(input.name, \" should be an array of string, number or BigNumber\"));\n          });\n          argPosition += 1;\n        } else if (/\\(felt/.test(input.type)) {\n          var tupleLength = input.type.split(',').length;\n          (0, minimalistic_assert_1.default)(args[argPosition].length === tupleLength, \"arg \".concat(input.name, \" should have \").concat(tupleLength, \" elements in tuple\"));\n          args[argPosition].forEach(function (felt) {\n            (0, minimalistic_assert_1.default)(typeof felt === 'string' || typeof felt === 'number' || felt instanceof bn_js_1.default, \"arg \".concat(input.name, \" should be an array of string, number or BigNumber\"));\n          });\n          argPosition += 1;\n        } else {\n          var arrayType_1 = input.type.replace('*', '');\n          args[argPosition].forEach(function (struct) {\n            _this.structs[arrayType_1].members.forEach(function (_a) {\n              var name = _a.name;\n              if (Array.isArray(struct)) {\n                var structMembersLength = _this.calculateStructMembers(arrayType_1);\n                (0, minimalistic_assert_1.default)(struct.length === structMembersLength, \"arg should be of length \".concat(structMembersLength));\n              } else {\n                (0, minimalistic_assert_1.default)(Object.keys(struct).includes(name), \"arg \".concat(input.name, \" should be an array of \").concat(arrayType_1));\n              }\n            });\n          });\n          argPosition += 1;\n        }\n      }\n    });\n  };\n  /**\n   * Deep parse of the object that has been passed to the method\n   *\n   * @param struct - struct that needs to be calculated\n   * @return {number} - number of members for the given struct\n   */\n  Contract.prototype.calculateStructMembers = function (struct) {\n    var _this = this;\n    return this.structs[struct].members.reduce(function (acc, member) {\n      if (member.type === 'felt') {\n        return acc + 1;\n      }\n      return acc + _this.calculateStructMembers(member.type);\n    }, 0);\n  };\n  /**\n   * Deep parse of the object that has been passed to the method\n   *\n   * @param element - element that needs to be parsed\n   * @param type  - name of the method\n   * @return {string | string[]} - parsed arguments in format that contract is expecting\n   */\n  Contract.prototype.parseCalldataValue = function (element, type) {\n    var _this = this;\n    if (element === undefined) {\n      throw Error('Missing element in calldata');\n    }\n    if (Array.isArray(element)) {\n      var structMemberNum = this.calculateStructMembers(type);\n      if (element.length !== structMemberNum) {\n        throw Error('Missing element in calldata');\n      }\n      return element.map(function (el) {\n        return (0, number_1.toFelt)(el);\n      });\n    }\n    // checking if the passed element is struct or element in struct\n    if (this.structs[type] && this.structs[type].members.length) {\n      // going through all the members of the struct and parsing the value\n      return this.structs[type].members.reduce(function (acc, member) {\n        // if the member of the struct is another struct this will return array of the felts if not it will be single felt\n        // TODO: refactor types so member name can be used as keyof ParsedStruct\n        /* @ts-ignore */\n        var parsedData = _this.parseCalldataValue(element[member.name], member.type);\n        if (typeof parsedData === 'string') {\n          acc.push(parsedData);\n        } else {\n          acc.push.apply(acc, __spreadArray([], __read(parsedData), false));\n        }\n        return acc;\n      }, []);\n    }\n    return (0, number_1.toFelt)(element);\n  };\n  /**\n   * Parse of the response elements that are converted to Object (Struct) by using the abi\n   *\n   * @param responseIterator - iterator of the response\n   * @param type - type of the struct\n   * @return {BigNumberish | ParsedStruct} - parsed arguments in format that contract is expecting\n   */\n  Contract.prototype.parseResponseStruct = function (responseIterator, type) {\n    var _this = this;\n    // check the type of current element\n    if (type in this.structs && this.structs[type]) {\n      return this.structs[type].members.reduce(function (acc, el) {\n        // parse each member of the struct (member can felt or nested struct)\n        acc[el.name] = _this.parseResponseStruct(responseIterator, el.type);\n        return acc;\n      }, {});\n    }\n    return parseFelt(responseIterator.next().value);\n  };\n  /**\n   * Parse one field of the calldata by using input field from the abi for that method\n   *\n   * @param args - value of the field\n   * @param input  - input(field) information from the abi that will be used to parse the data\n   * @return {string | string[]} - parsed arguments in format that contract is expecting\n   */\n  Contract.prototype.parseCalldataField = function (argsIterator, input) {\n    var _this = this;\n    var name = input.name,\n      type = input.type;\n    var value = argsIterator.next().value;\n    var parsedCalldata = [];\n    switch (true) {\n      case /\\*/.test(type):\n        if (Array.isArray(value)) {\n          parsedCalldata.push((0, number_1.toFelt)(value.length));\n          return value.reduce(function (acc, el) {\n            if (/felt/.test(type)) {\n              acc.push((0, number_1.toFelt)(el));\n            } else {\n              acc.push.apply(acc, __spreadArray([], __read(_this.parseCalldataValue(el, type.replace('*', ''))), false));\n            }\n            return acc;\n          }, parsedCalldata);\n        }\n        throw Error(\"Expected \".concat(name, \" to be array\"));\n      case type in this.structs:\n        return this.parseCalldataValue(value, type);\n      case /\\(felt/.test(type):\n        if (Array.isArray(value)) {\n          return value.map(function (el) {\n            return (0, number_1.toFelt)(el);\n          });\n        }\n        throw Error(\"Expected \".concat(name, \" to be array\"));\n      default:\n        return (0, number_1.toFelt)(value);\n    }\n  };\n  /**\n   * Parse the calldata by using input fields from the abi for that method\n   *\n   * @param args - arguments passed the the method\n   * @param inputs  - list of inputs(fields) that are in the abi\n   * @return {Calldata} - parsed arguments in format that contract is expecting\n   */\n  Contract.prototype.compileCalldata = function (args, inputs) {\n    var _this = this;\n    var argsIterator = args[Symbol.iterator]();\n    return inputs.reduce(function (acc, input) {\n      if (/_len$/.test(input.name)) {\n        return acc;\n      }\n      var parsedData = _this.parseCalldataField(argsIterator, input);\n      if (Array.isArray(parsedData)) {\n        acc.push.apply(acc, __spreadArray([], __read(parsedData), false));\n      } else {\n        acc.push(parsedData);\n      }\n      return acc;\n    }, []);\n  };\n  /**\n   * Parse elements of the response and structuring them into one field by using output property from the abi for that method\n   *\n   * @param responseIterator - iterator of the response\n   * @param output  - output(field) information from the abi that will be used to parse the data\n   * @return - parsed response corresponding to the abi structure of the field\n   */\n  Contract.prototype.parseResponseField = function (responseIterator, output, parsedResult) {\n    var name = output.name,\n      type = output.type;\n    var parsedDataArr = [];\n    switch (true) {\n      case /_len$/.test(name):\n        return parseFelt(responseIterator.next().value).toNumber();\n      case /\\(felt/.test(type):\n        return type.split(',').reduce(function (acc) {\n          acc.push(parseFelt(responseIterator.next().value));\n          return acc;\n        }, []);\n      case /\\*/.test(type):\n        if (parsedResult && parsedResult[\"\".concat(name, \"_len\")]) {\n          var arrLen = parsedResult[\"\".concat(name, \"_len\")];\n          while (parsedDataArr.length < arrLen) {\n            parsedDataArr.push(this.parseResponseStruct(responseIterator, output.type.replace('*', '')));\n          }\n        }\n        return parsedDataArr;\n      case type in this.structs:\n        return this.parseResponseStruct(responseIterator, type);\n      default:\n        return parseFelt(responseIterator.next().value);\n    }\n  };\n  /**\n   * Parse elements of the response array and structuring them into response object\n   *\n   * @param method - method name\n   * @param response  - response from the method\n   * @return - parsed response corresponding to the abi\n   */\n  Contract.prototype.parseResponse = function (method, response) {\n    var _this = this;\n    var outputs = this.abi.find(function (abi) {\n      return abi.name === method;\n    }).outputs;\n    var responseIterator = response.flat()[Symbol.iterator]();\n    var resultObject = outputs.flat().reduce(function (acc, output) {\n      acc[output.name] = _this.parseResponseField(responseIterator, output, acc);\n      if (acc[output.name] && acc[\"\".concat(output.name, \"_len\")]) {\n        delete acc[\"\".concat(output.name, \"_len\")];\n      }\n      return acc;\n    }, {});\n    return Object.entries(resultObject).reduce(function (acc, _a) {\n      var _b = __read(_a, 2),\n        key = _b[0],\n        value = _b[1];\n      acc.push(value);\n      acc[key] = value;\n      return acc;\n    }, []);\n  };\n  Contract.prototype.invoke = function (method, args, options) {\n    if (args === void 0) {\n      args = [];\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    // ensure contract is connected\n    (0, minimalistic_assert_1.default)(this.address !== null, 'contract is not connected to an address');\n    // validate method and args\n    this.validateMethodAndArgs('INVOKE', method, args);\n    var inputs = this.abi.find(function (abi) {\n      return abi.name === method;\n    }).inputs;\n    var inputsLength = inputs.reduce(function (acc, input) {\n      if (!/_len$/.test(input.name)) {\n        return acc + 1;\n      }\n      return acc;\n    }, 0);\n    if (args.length !== inputsLength) {\n      throw Error(\"Invalid number of arguments, expected \".concat(inputsLength, \" arguments, but got \").concat(args.length));\n    }\n    // compile calldata\n    var calldata = this.compileCalldata(args, inputs);\n    var invocation = {\n      contractAddress: this.address,\n      calldata: calldata,\n      entrypoint: method\n    };\n    if ('execute' in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, undefined, {\n        maxFee: options.maxFee,\n        nonce: options.nonce\n      });\n    }\n    if (!options.nonce) {\n      throw new Error(\"Nonce is required when invoking a function without an account\");\n    }\n    // eslint-disable-next-line no-console\n    console.warn(\"Invoking \".concat(method, \" without an account. This will not work on a public node.\"));\n    return this.providerOrAccount.invokeFunction(__assign(__assign({}, invocation), {\n      signature: options.signature || []\n    }), {\n      nonce: options.nonce\n    });\n  };\n  Contract.prototype.call = function (method, args, _a) {\n    if (args === void 0) {\n      args = [];\n    }\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.blockIdentifier,\n      blockIdentifier = _c === void 0 ? 'pending' : _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var inputs, calldata;\n      var _this = this;\n      return __generator(this, function (_d) {\n        // ensure contract is connected\n        (0, minimalistic_assert_1.default)(this.address !== null, 'contract is not connected to an address');\n        // validate method and args\n        this.validateMethodAndArgs('CALL', method, args);\n        inputs = this.abi.find(function (abi) {\n          return abi.name === method;\n        }).inputs;\n        calldata = this.compileCalldata(args, inputs);\n        return [2 /*return*/, this.providerOrAccount.callContract({\n          contractAddress: this.address,\n          calldata: calldata,\n          entrypoint: method\n        }, blockIdentifier).then(function (x) {\n          return _this.parseResponse(method, x.result);\n        })];\n      });\n    });\n  };\n  Contract.prototype.estimate = function (method, args) {\n    if (args === void 0) {\n      args = [];\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var invocation;\n      var _a;\n      return __generator(this, function (_b) {\n        // ensure contract is connected\n        (0, minimalistic_assert_1.default)(this.address !== null, 'contract is not connected to an address');\n        // validate method and args\n        this.validateMethodAndArgs('INVOKE', method, args);\n        invocation = (_a = this.populateTransaction)[method].apply(_a, __spreadArray([], __read(args), false));\n        if ('estimateInvokeFee' in this.providerOrAccount) {\n          return [2 /*return*/, this.providerOrAccount.estimateInvokeFee(invocation)];\n        }\n        throw Error('Contract must be connected to the account contract to estimate');\n      });\n    });\n  };\n  Contract.prototype.populate = function (method, args) {\n    if (args === void 0) {\n      args = [];\n    }\n    var inputs = this.abi.find(function (abi) {\n      return abi.name === method;\n    }).inputs;\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata: this.compileCalldata(args, inputs)\n    };\n  };\n  return Contract;\n}();\nexports.Contract = Contract;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","Symbol","iterator","v","op","TypeError","pop","push","__read","o","m","r","ar","error","__spreadArray","to","from","pack","l","Array","slice","concat","__importDefault","mod","__esModule","defineProperty","exports","Contract","bn_js_1","require","minimalistic_assert_1","provider_1","number_1","parseFelt","candidate","toBN","Error","buildCall","contract","functionAbi","args","_i","_a","name","buildInvoke","inputs","inputsLength","options","reduce","acc","input","test","invoke","buildDefault","stateMutability","buildPopulate","populate","buildEstimate","estimate","abi","address","providerOrAccount","defaultProvider","_this","toLowerCase","structs","filter","abiEntry","type","enumerable","writable","forEach","abiElement","signature","functions","callStatic","populateTransaction","estimateFee","attach","connect","deployed","deployTransactionHash","waitForTransaction","undefined","validateMethodAndArgs","method","invokeableFunctionNames","isView","map","default","includes","methodAbi","find","argPosition","isArray","structMembersLength","calculateStructMembers","members","keys","felt","tupleLength","split","arrayType_1","replace","struct","member","parseCalldataValue","element","structMemberNum","el","toFelt","parsedData","parseResponseStruct","responseIterator","parseCalldataField","argsIterator","parsedCalldata","compileCalldata","parseResponseField","output","parsedResult","parsedDataArr","toNumber","arrLen","parseResponse","response","outputs","flat","resultObject","entries","_b","key","calldata","invocation","contractAddress","entrypoint","execute","maxFee","nonce","console","warn","invokeFunction","_c","blockIdentifier","_d","callContract","x","estimateInvokeFee"],"sources":["C:/Users/admin/Documents/Blockchain test/CairoBootcamp/starknet_js_demo/node_modules/starknet/dist/contract/default.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Contract = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar minimalistic_assert_1 = __importDefault(require(\"minimalistic-assert\"));\nvar provider_1 = require(\"../provider\");\nvar number_1 = require(\"../utils/number\");\nfunction parseFelt(candidate) {\n    try {\n        return (0, number_1.toBN)(candidate);\n    }\n    catch (e) {\n        throw Error('Couldnt parse felt');\n    }\n}\n/**\n * Adds call methods to the contract\n *\n */\nfunction buildCall(contract, functionAbi) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, contract.call(functionAbi.name, args)];\n            });\n        });\n    };\n}\n/**\n * Adds invoke methods to the contract\n *\n */\nfunction buildInvoke(contract, functionAbi) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return __awaiter(this, void 0, void 0, function () {\n            var inputs, inputsLength, options;\n            return __generator(this, function (_a) {\n                inputs = functionAbi.inputs;\n                inputsLength = inputs.reduce(function (acc, input) {\n                    if (!/_len$/.test(input.name)) {\n                        return acc + 1;\n                    }\n                    return acc;\n                }, 0);\n                options = {};\n                if (inputsLength + 1 === args.length && typeof args[args.length - 1] === 'object') {\n                    Object.assign(options, args.pop());\n                }\n                return [2 /*return*/, contract.invoke(functionAbi.name, args, options)];\n            });\n        });\n    };\n}\n/**\n * Adds call/invoke methods to the contract\n *\n */\nfunction buildDefault(contract, functionAbi) {\n    if (functionAbi.stateMutability === 'view') {\n        return buildCall(contract, functionAbi);\n    }\n    return buildInvoke(contract, functionAbi);\n}\n/**\n * Adds populate for methods to the contract\n *\n */\nfunction buildPopulate(contract, functionAbi) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return contract.populate(functionAbi.name, args);\n    };\n}\n/**\n * Adds estimateFee for methods to the contract\n *\n */\nfunction buildEstimate(contract, functionAbi) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return contract.estimate(functionAbi.name, args);\n    };\n}\nvar Contract = /** @class */ (function () {\n    /**\n     * Contract class to handle contract methods\n     *\n     * @param abi - Abi of the contract object\n     * @param address (optional) - address to connect to\n     * @param providerOrAccount (optional) - Provider or Account to attach to\n     */\n    function Contract(abi, address, providerOrAccount) {\n        if (providerOrAccount === void 0) { providerOrAccount = provider_1.defaultProvider; }\n        var _this = this;\n        this.address = address && address.toLowerCase();\n        this.providerOrAccount = providerOrAccount;\n        this.abi = abi;\n        this.structs = abi\n            .filter(function (abiEntry) { return abiEntry.type === 'struct'; })\n            .reduce(function (acc, abiEntry) {\n            var _a;\n            return (__assign(__assign({}, acc), (_a = {}, _a[abiEntry.name] = abiEntry, _a)));\n        }, {});\n        Object.defineProperty(this, 'functions', {\n            enumerable: true,\n            value: {},\n            writable: false,\n        });\n        Object.defineProperty(this, 'callStatic', {\n            enumerable: true,\n            value: {},\n            writable: false,\n        });\n        Object.defineProperty(this, 'populateTransaction', {\n            enumerable: true,\n            value: {},\n            writable: false,\n        });\n        Object.defineProperty(this, 'estimateFee', {\n            enumerable: true,\n            value: {},\n            writable: false,\n        });\n        this.abi.forEach(function (abiElement) {\n            if (abiElement.type !== 'function') {\n                return;\n            }\n            var signature = abiElement.name;\n            if (!_this[signature]) {\n                Object.defineProperty(_this, signature, {\n                    enumerable: true,\n                    value: buildDefault(_this, abiElement),\n                    writable: false,\n                });\n            }\n            if (!_this.functions[signature]) {\n                Object.defineProperty(_this.functions, signature, {\n                    enumerable: true,\n                    value: buildDefault(_this, abiElement),\n                    writable: false,\n                });\n            }\n            if (!_this.callStatic[signature]) {\n                Object.defineProperty(_this.callStatic, signature, {\n                    enumerable: true,\n                    value: buildCall(_this, abiElement),\n                    writable: false,\n                });\n            }\n            if (!_this.populateTransaction[signature]) {\n                Object.defineProperty(_this.populateTransaction, signature, {\n                    enumerable: true,\n                    value: buildPopulate(_this, abiElement),\n                    writable: false,\n                });\n            }\n            if (!_this.estimateFee[signature]) {\n                Object.defineProperty(_this.estimateFee, signature, {\n                    enumerable: true,\n                    value: buildEstimate(_this, abiElement),\n                    writable: false,\n                });\n            }\n        });\n    }\n    /**\n     * Saves the address of the contract deployed on network that will be used for interaction\n     *\n     * @param address - address of the contract\n     */\n    Contract.prototype.attach = function (address) {\n        this.address = address;\n    };\n    /**\n     * Attaches to new Provider or Account\n     *\n     * @param providerOrAccount - new Provider or Account to attach to\n     */\n    Contract.prototype.connect = function (providerOrAccount) {\n        this.providerOrAccount = providerOrAccount;\n    };\n    /**\n     * Resolves when contract is deployed on the network or when no deployment transaction is found\n     *\n     * @returns Promise that resolves when contract is deployed on the network or when no deployment transaction is found\n     * @throws When deployment fails\n     */\n    Contract.prototype.deployed = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.deployTransactionHash) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.providerOrAccount.waitForTransaction(this.deployTransactionHash)];\n                    case 1:\n                        _a.sent();\n                        this.deployTransactionHash = undefined;\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, this];\n                }\n            });\n        });\n    };\n    /**\n     * Validates if all arguments that are passed to the method are corresponding to the ones in the abi\n     *\n     * @param type - type of the method\n     * @param method  - name of the method\n     * @param args - arguments that are passed to the method\n     */\n    Contract.prototype.validateMethodAndArgs = function (type, method, args) {\n        var _this = this;\n        if (args === void 0) { args = []; }\n        // ensure provided method exists\n        var invokeableFunctionNames = this.abi\n            .filter(function (abi) {\n            if (abi.type !== 'function')\n                return false;\n            var isView = abi.stateMutability === 'view';\n            return type === 'INVOKE' ? !isView : isView;\n        })\n            .map(function (abi) { return abi.name; });\n        (0, minimalistic_assert_1.default)(invokeableFunctionNames.includes(method), \"\".concat(type === 'INVOKE' ? 'invokeable' : 'viewable', \" method not found in abi\"));\n        // ensure args match abi type\n        var methodAbi = this.abi.find(function (abi) { return abi.name === method && abi.type === 'function'; });\n        var argPosition = 0;\n        methodAbi.inputs.forEach(function (input) {\n            if (/_len$/.test(input.name)) {\n                return;\n            }\n            if (input.type === 'felt') {\n                (0, minimalistic_assert_1.default)(typeof args[argPosition] === 'string' ||\n                    typeof args[argPosition] === 'number' ||\n                    args[argPosition] instanceof bn_js_1.default, \"arg \".concat(input.name, \" should be a felt (string, number, BigNumber)\"));\n                argPosition += 1;\n            }\n            else if (input.type in _this.structs && typeof args[argPosition] === 'object') {\n                if (Array.isArray(args[argPosition])) {\n                    var structMembersLength = _this.calculateStructMembers(input.type);\n                    (0, minimalistic_assert_1.default)(args[argPosition].length === structMembersLength, \"arg should be of length \".concat(structMembersLength));\n                }\n                else {\n                    _this.structs[input.type].members.forEach(function (_a) {\n                        var name = _a.name;\n                        (0, minimalistic_assert_1.default)(Object.keys(args[argPosition]).includes(name), \"arg should have a property \".concat(name));\n                    });\n                }\n                argPosition += 1;\n            }\n            else {\n                (0, minimalistic_assert_1.default)(Array.isArray(args[argPosition]), \"arg \".concat(input.name, \" should be an Array\"));\n                if (input.type === 'felt*') {\n                    args[argPosition].forEach(function (felt) {\n                        (0, minimalistic_assert_1.default)(typeof felt === 'string' || typeof felt === 'number' || felt instanceof bn_js_1.default, \"arg \".concat(input.name, \" should be an array of string, number or BigNumber\"));\n                    });\n                    argPosition += 1;\n                }\n                else if (/\\(felt/.test(input.type)) {\n                    var tupleLength = input.type.split(',').length;\n                    (0, minimalistic_assert_1.default)(args[argPosition].length === tupleLength, \"arg \".concat(input.name, \" should have \").concat(tupleLength, \" elements in tuple\"));\n                    args[argPosition].forEach(function (felt) {\n                        (0, minimalistic_assert_1.default)(typeof felt === 'string' || typeof felt === 'number' || felt instanceof bn_js_1.default, \"arg \".concat(input.name, \" should be an array of string, number or BigNumber\"));\n                    });\n                    argPosition += 1;\n                }\n                else {\n                    var arrayType_1 = input.type.replace('*', '');\n                    args[argPosition].forEach(function (struct) {\n                        _this.structs[arrayType_1].members.forEach(function (_a) {\n                            var name = _a.name;\n                            if (Array.isArray(struct)) {\n                                var structMembersLength = _this.calculateStructMembers(arrayType_1);\n                                (0, minimalistic_assert_1.default)(struct.length === structMembersLength, \"arg should be of length \".concat(structMembersLength));\n                            }\n                            else {\n                                (0, minimalistic_assert_1.default)(Object.keys(struct).includes(name), \"arg \".concat(input.name, \" should be an array of \").concat(arrayType_1));\n                            }\n                        });\n                    });\n                    argPosition += 1;\n                }\n            }\n        });\n    };\n    /**\n     * Deep parse of the object that has been passed to the method\n     *\n     * @param struct - struct that needs to be calculated\n     * @return {number} - number of members for the given struct\n     */\n    Contract.prototype.calculateStructMembers = function (struct) {\n        var _this = this;\n        return this.structs[struct].members.reduce(function (acc, member) {\n            if (member.type === 'felt') {\n                return acc + 1;\n            }\n            return acc + _this.calculateStructMembers(member.type);\n        }, 0);\n    };\n    /**\n     * Deep parse of the object that has been passed to the method\n     *\n     * @param element - element that needs to be parsed\n     * @param type  - name of the method\n     * @return {string | string[]} - parsed arguments in format that contract is expecting\n     */\n    Contract.prototype.parseCalldataValue = function (element, type) {\n        var _this = this;\n        if (element === undefined) {\n            throw Error('Missing element in calldata');\n        }\n        if (Array.isArray(element)) {\n            var structMemberNum = this.calculateStructMembers(type);\n            if (element.length !== structMemberNum) {\n                throw Error('Missing element in calldata');\n            }\n            return element.map(function (el) { return (0, number_1.toFelt)(el); });\n        }\n        // checking if the passed element is struct or element in struct\n        if (this.structs[type] && this.structs[type].members.length) {\n            // going through all the members of the struct and parsing the value\n            return this.structs[type].members.reduce(function (acc, member) {\n                // if the member of the struct is another struct this will return array of the felts if not it will be single felt\n                // TODO: refactor types so member name can be used as keyof ParsedStruct\n                /* @ts-ignore */\n                var parsedData = _this.parseCalldataValue(element[member.name], member.type);\n                if (typeof parsedData === 'string') {\n                    acc.push(parsedData);\n                }\n                else {\n                    acc.push.apply(acc, __spreadArray([], __read(parsedData), false));\n                }\n                return acc;\n            }, []);\n        }\n        return (0, number_1.toFelt)(element);\n    };\n    /**\n     * Parse of the response elements that are converted to Object (Struct) by using the abi\n     *\n     * @param responseIterator - iterator of the response\n     * @param type - type of the struct\n     * @return {BigNumberish | ParsedStruct} - parsed arguments in format that contract is expecting\n     */\n    Contract.prototype.parseResponseStruct = function (responseIterator, type) {\n        var _this = this;\n        // check the type of current element\n        if (type in this.structs && this.structs[type]) {\n            return this.structs[type].members.reduce(function (acc, el) {\n                // parse each member of the struct (member can felt or nested struct)\n                acc[el.name] = _this.parseResponseStruct(responseIterator, el.type);\n                return acc;\n            }, {});\n        }\n        return parseFelt(responseIterator.next().value);\n    };\n    /**\n     * Parse one field of the calldata by using input field from the abi for that method\n     *\n     * @param args - value of the field\n     * @param input  - input(field) information from the abi that will be used to parse the data\n     * @return {string | string[]} - parsed arguments in format that contract is expecting\n     */\n    Contract.prototype.parseCalldataField = function (argsIterator, input) {\n        var _this = this;\n        var name = input.name, type = input.type;\n        var value = argsIterator.next().value;\n        var parsedCalldata = [];\n        switch (true) {\n            case /\\*/.test(type):\n                if (Array.isArray(value)) {\n                    parsedCalldata.push((0, number_1.toFelt)(value.length));\n                    return value.reduce(function (acc, el) {\n                        if (/felt/.test(type)) {\n                            acc.push((0, number_1.toFelt)(el));\n                        }\n                        else {\n                            acc.push.apply(acc, __spreadArray([], __read(_this.parseCalldataValue(el, type.replace('*', ''))), false));\n                        }\n                        return acc;\n                    }, parsedCalldata);\n                }\n                throw Error(\"Expected \".concat(name, \" to be array\"));\n            case type in this.structs:\n                return this.parseCalldataValue(value, type);\n            case /\\(felt/.test(type):\n                if (Array.isArray(value)) {\n                    return value.map(function (el) { return (0, number_1.toFelt)(el); });\n                }\n                throw Error(\"Expected \".concat(name, \" to be array\"));\n            default:\n                return (0, number_1.toFelt)(value);\n        }\n    };\n    /**\n     * Parse the calldata by using input fields from the abi for that method\n     *\n     * @param args - arguments passed the the method\n     * @param inputs  - list of inputs(fields) that are in the abi\n     * @return {Calldata} - parsed arguments in format that contract is expecting\n     */\n    Contract.prototype.compileCalldata = function (args, inputs) {\n        var _this = this;\n        var argsIterator = args[Symbol.iterator]();\n        return inputs.reduce(function (acc, input) {\n            if (/_len$/.test(input.name)) {\n                return acc;\n            }\n            var parsedData = _this.parseCalldataField(argsIterator, input);\n            if (Array.isArray(parsedData)) {\n                acc.push.apply(acc, __spreadArray([], __read(parsedData), false));\n            }\n            else {\n                acc.push(parsedData);\n            }\n            return acc;\n        }, []);\n    };\n    /**\n     * Parse elements of the response and structuring them into one field by using output property from the abi for that method\n     *\n     * @param responseIterator - iterator of the response\n     * @param output  - output(field) information from the abi that will be used to parse the data\n     * @return - parsed response corresponding to the abi structure of the field\n     */\n    Contract.prototype.parseResponseField = function (responseIterator, output, parsedResult) {\n        var name = output.name, type = output.type;\n        var parsedDataArr = [];\n        switch (true) {\n            case /_len$/.test(name):\n                return parseFelt(responseIterator.next().value).toNumber();\n            case /\\(felt/.test(type):\n                return type.split(',').reduce(function (acc) {\n                    acc.push(parseFelt(responseIterator.next().value));\n                    return acc;\n                }, []);\n            case /\\*/.test(type):\n                if (parsedResult && parsedResult[\"\".concat(name, \"_len\")]) {\n                    var arrLen = parsedResult[\"\".concat(name, \"_len\")];\n                    while (parsedDataArr.length < arrLen) {\n                        parsedDataArr.push(this.parseResponseStruct(responseIterator, output.type.replace('*', '')));\n                    }\n                }\n                return parsedDataArr;\n            case type in this.structs:\n                return this.parseResponseStruct(responseIterator, type);\n            default:\n                return parseFelt(responseIterator.next().value);\n        }\n    };\n    /**\n     * Parse elements of the response array and structuring them into response object\n     *\n     * @param method - method name\n     * @param response  - response from the method\n     * @return - parsed response corresponding to the abi\n     */\n    Contract.prototype.parseResponse = function (method, response) {\n        var _this = this;\n        var outputs = this.abi.find(function (abi) { return abi.name === method; }).outputs;\n        var responseIterator = response.flat()[Symbol.iterator]();\n        var resultObject = outputs.flat().reduce(function (acc, output) {\n            acc[output.name] = _this.parseResponseField(responseIterator, output, acc);\n            if (acc[output.name] && acc[\"\".concat(output.name, \"_len\")]) {\n                delete acc[\"\".concat(output.name, \"_len\")];\n            }\n            return acc;\n        }, {});\n        return Object.entries(resultObject).reduce(function (acc, _a) {\n            var _b = __read(_a, 2), key = _b[0], value = _b[1];\n            acc.push(value);\n            acc[key] = value;\n            return acc;\n        }, []);\n    };\n    Contract.prototype.invoke = function (method, args, options) {\n        if (args === void 0) { args = []; }\n        if (options === void 0) { options = {}; }\n        // ensure contract is connected\n        (0, minimalistic_assert_1.default)(this.address !== null, 'contract is not connected to an address');\n        // validate method and args\n        this.validateMethodAndArgs('INVOKE', method, args);\n        var inputs = this.abi.find(function (abi) { return abi.name === method; }).inputs;\n        var inputsLength = inputs.reduce(function (acc, input) {\n            if (!/_len$/.test(input.name)) {\n                return acc + 1;\n            }\n            return acc;\n        }, 0);\n        if (args.length !== inputsLength) {\n            throw Error(\"Invalid number of arguments, expected \".concat(inputsLength, \" arguments, but got \").concat(args.length));\n        }\n        // compile calldata\n        var calldata = this.compileCalldata(args, inputs);\n        var invocation = {\n            contractAddress: this.address,\n            calldata: calldata,\n            entrypoint: method,\n        };\n        if ('execute' in this.providerOrAccount) {\n            return this.providerOrAccount.execute(invocation, undefined, {\n                maxFee: options.maxFee,\n                nonce: options.nonce,\n            });\n        }\n        if (!options.nonce) {\n            throw new Error(\"Nonce is required when invoking a function without an account\");\n        }\n        // eslint-disable-next-line no-console\n        console.warn(\"Invoking \".concat(method, \" without an account. This will not work on a public node.\"));\n        return this.providerOrAccount.invokeFunction(__assign(__assign({}, invocation), { signature: options.signature || [] }), {\n            nonce: options.nonce,\n        });\n    };\n    Contract.prototype.call = function (method, args, _a) {\n        if (args === void 0) { args = []; }\n        var _b = _a === void 0 ? {} : _a, _c = _b.blockIdentifier, blockIdentifier = _c === void 0 ? 'pending' : _c;\n        return __awaiter(this, void 0, void 0, function () {\n            var inputs, calldata;\n            var _this = this;\n            return __generator(this, function (_d) {\n                // ensure contract is connected\n                (0, minimalistic_assert_1.default)(this.address !== null, 'contract is not connected to an address');\n                // validate method and args\n                this.validateMethodAndArgs('CALL', method, args);\n                inputs = this.abi.find(function (abi) { return abi.name === method; }).inputs;\n                calldata = this.compileCalldata(args, inputs);\n                return [2 /*return*/, this.providerOrAccount\n                        .callContract({\n                        contractAddress: this.address,\n                        calldata: calldata,\n                        entrypoint: method,\n                    }, blockIdentifier)\n                        .then(function (x) { return _this.parseResponse(method, x.result); })];\n            });\n        });\n    };\n    Contract.prototype.estimate = function (method, args) {\n        if (args === void 0) { args = []; }\n        return __awaiter(this, void 0, void 0, function () {\n            var invocation;\n            var _a;\n            return __generator(this, function (_b) {\n                // ensure contract is connected\n                (0, minimalistic_assert_1.default)(this.address !== null, 'contract is not connected to an address');\n                // validate method and args\n                this.validateMethodAndArgs('INVOKE', method, args);\n                invocation = (_a = this.populateTransaction)[method].apply(_a, __spreadArray([], __read(args), false));\n                if ('estimateInvokeFee' in this.providerOrAccount) {\n                    return [2 /*return*/, this.providerOrAccount.estimateInvokeFee(invocation)];\n                }\n                throw Error('Contract must be connected to the account contract to estimate');\n            });\n        });\n    };\n    Contract.prototype.populate = function (method, args) {\n        if (args === void 0) { args = []; }\n        var inputs = this.abi.find(function (abi) { return abi.name === method; }).inputs;\n        return {\n            contractAddress: this.address,\n            entrypoint: method,\n            calldata: this.compileCalldata(args, inputs),\n        };\n    };\n    return Contract;\n}());\nexports.Contract = Contract;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}