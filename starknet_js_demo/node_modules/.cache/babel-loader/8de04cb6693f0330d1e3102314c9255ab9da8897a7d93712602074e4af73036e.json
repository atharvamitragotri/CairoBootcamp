{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateChecksumAddress = exports.getChecksumAddress = exports.validateAndParseAddress = exports.addAddressPadding = void 0;\n/* eslint-disable no-bitwise */\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar constants_1 = require(\"../constants\");\nvar encode_1 = require(\"./encode\");\nvar hash_1 = require(\"./hash\");\nvar number_1 = require(\"./number\");\nfunction addAddressPadding(address) {\n  return (0, encode_1.addHexPrefix)((0, encode_1.removeHexPrefix)((0, number_1.toHex)((0, number_1.toBN)(address))).padStart(64, '0'));\n}\nexports.addAddressPadding = addAddressPadding;\nfunction validateAndParseAddress(address) {\n  (0, number_1.assertInRange)(address, constants_1.ZERO, constants_1.MASK_251, 'Starknet Address');\n  var result = addAddressPadding(address);\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid Address Format');\n  }\n  return result;\n}\nexports.validateAndParseAddress = validateAndParseAddress;\n// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12\nfunction getChecksumAddress(address) {\n  var chars = (0, encode_1.removeHexPrefix)(validateAndParseAddress(address)).toLowerCase().split('');\n  var hashed = (0, bytes_1.arrayify)((0, hash_1.keccakBn)(address), {\n    hexPad: 'left'\n  }); // in case the hash is 251 bits (63 chars) we need to pad it to 64 chars without changing the number value (\"left\")\n  for (var i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return (0, encode_1.addHexPrefix)(chars.join(''));\n}\nexports.getChecksumAddress = getChecksumAddress;\nfunction validateChecksumAddress(address) {\n  return getChecksumAddress(address) === address;\n}\nexports.validateChecksumAddress = validateChecksumAddress;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateChecksumAddress","getChecksumAddress","validateAndParseAddress","addAddressPadding","bytes_1","require","constants_1","encode_1","hash_1","number_1","address","addHexPrefix","removeHexPrefix","toHex","toBN","padStart","assertInRange","ZERO","MASK_251","result","match","Error","chars","toLowerCase","split","hashed","arrayify","keccakBn","hexPad","i","length","toUpperCase","join"],"sources":["C:/Users/admin/Documents/Blockchain test/CairoBootcamp/starknet_js_demo/node_modules/starknet/dist/utils/address.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateChecksumAddress = exports.getChecksumAddress = exports.validateAndParseAddress = exports.addAddressPadding = void 0;\n/* eslint-disable no-bitwise */\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar constants_1 = require(\"../constants\");\nvar encode_1 = require(\"./encode\");\nvar hash_1 = require(\"./hash\");\nvar number_1 = require(\"./number\");\nfunction addAddressPadding(address) {\n    return (0, encode_1.addHexPrefix)((0, encode_1.removeHexPrefix)((0, number_1.toHex)((0, number_1.toBN)(address))).padStart(64, '0'));\n}\nexports.addAddressPadding = addAddressPadding;\nfunction validateAndParseAddress(address) {\n    (0, number_1.assertInRange)(address, constants_1.ZERO, constants_1.MASK_251, 'Starknet Address');\n    var result = addAddressPadding(address);\n    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n        throw new Error('Invalid Address Format');\n    }\n    return result;\n}\nexports.validateAndParseAddress = validateAndParseAddress;\n// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12\nfunction getChecksumAddress(address) {\n    var chars = (0, encode_1.removeHexPrefix)(validateAndParseAddress(address)).toLowerCase().split('');\n    var hashed = (0, bytes_1.arrayify)((0, hash_1.keccakBn)(address), { hexPad: 'left' }); // in case the hash is 251 bits (63 chars) we need to pad it to 64 chars without changing the number value (\"left\")\n    for (var i = 0; i < chars.length; i += 2) {\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return (0, encode_1.addHexPrefix)(chars.join(''));\n}\nexports.getChecksumAddress = getChecksumAddress;\nfunction validateChecksumAddress(address) {\n    return getChecksumAddress(address) === address;\n}\nexports.validateChecksumAddress = validateChecksumAddress;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}